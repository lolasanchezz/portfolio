[{"name":"ntwatch","shortname":"ntwatch","favorite":true,"desc":"packets and processes - wireshark + nettop","links":{"gh":"https://github.com/lolasanchezz/ntwatch","demo":"https://github.com/lolasanchezz/ntwatch/releases/tag/v0.3.5"},"images":[{"src":"v1_ntwatch.png","subtitle":"first version - illustrates use of cgo to use c libraries with go cli libraries","asp":0.6},{"src":"design.png","subtitle":"system design","asp":0.6}],"text":[{"header":"Summary","body":"A CLI to track internet usage through live packet capture and socket analysis."},{"header":"Inspiration","body":"I was initially inspired by wireshark - an app that, although extremely practical,         is very myopic in its presentation of data. While packets can be sorted, it takes extra work to extrapolate patterns about network traffic.         While knowing specific packet data could be useful, I wanted to know broader information about the behavior of all the processes on my computer         to detect malware, bugs, or abnormal patterns in network traffic. I found myself using nettop right next to wireshark to match packets to processes,         which inspired me to make ntwatch - a combination of processes and packets."},{"header":"v0.35","body":"I first started by exploring existing go libraries to read socket data. I wanted to do it as low level and efficient as possible, as I knew       I would be examining sockets alongside packets, which would come in extremely quickly and in huge amounts. AKA, no exec calls of lsof. However, existing go-socket libraries for macos       were incomplete and buggy. While I might attempt to fix such libraries in the future, at the beginning, I really just wanted to get a working prototype going. Therefore, my       first goal was to access socket data through go with c's libproc, a macos provided c library to access proc(ess) data. That's why the first version (aka v0.5), pictured above, is       a go program with bubbletea displaying all socket information through cgo. In all, this part was the hardest - it was a lot of research into libproc, a barely used       library, and on what socket struct values actually mean, considering macos provides very little documentation. In all, I ended up with a prettier version of       nettop/netstat, which was already an accomplishment in and of itself. I ended up submitting v0.5 as a project for Hack Club's Athena Award."},{"header":"v1.0","body":"After ensuring I could access sockets through go in v0.5, I started on progressing towards the full version of ntwatch, which would display packets alongside processes.       I decided on the above design, facilitating communication between the packet collection process and the cgo socket reading through bubbletea's cmds. I wanted to keep the       two processes completely seperate and have them constantly running asynchronously, in order to recieve packets and sockets as quickly as possible. I came up with a simple       matching process to match sockets and packets by just matching those which had the same listening/outgoing ip, process name, and source/destination port. While the GUI still       needs work, the core functionality is done."}]},{"shortname":"journalcli","name":"journalcli","favorite":true,"desc":"an encrypted journal in the terminal","links":{"gh":"github.com/lolasanchezz/journalcli","demo":"github.com/lolasanchezz/journalcli/releases/tag/main"},"images":[{"src":"final.gif","subtitle":"in action!","asp":0.7}],"text":[{"header":"Summary","body":"an encrypted journal through the terminal!"},{"header":"Inspiration","body":"I wanted a journaling app that would be discrete, extremely straightforward without bugs or distractions, and secure to onlookers.         Most journaling apps I found were too complex, making journaling a task instead of a sidenote about the day. Journaling apps were about         flashy features, not just journaling, which discouraged me to journal. So I decided to make a journaling cli in the terminal - the most straightforward         interface you can get."},{"header":"Overview","body":"While this journaling cli doesn't exactly offer anything technologically novel, it excels in its aesthetic and simplicity. At the end         of the day, I just wanted a journaling app that would be encrypted, work well, and encourage me to journal. Its main features are past journal viewing,        analytics (word count per entry, etc), and searchable entries through filtering.  There was a lot of work that went into         this app that's un-noticeable - smooth scrolling, keybinds, constantly updating configuration, etc - which is the hallmark of a well designed UI/UX.         Each 'page' of the website has its own component and styling, and every journal entry is AES encrypted. Journal entries can even be edited after         being made. This project was tedious, but worth it - it's a clean journaling app that I actually use."},{"header":"Features","body":""}]},{"shortname":"sec","name":"graph the sec","favorite":false,"desc":"security and exchange commission data graphed","links":{"gh":"github.com/lolasanchezz/sec-frontend","demo":"graphthesec.xyz"},"images":[{"src":"landing.png","subtitle":"home page","asp":1},{"src":"mtnsearch.png","subtitle":"searching for company with ticker MTN's data","asp":0.8},{"src":"search.png","subtitle":"the results!","asp":0.8}],"text":[{"header":"Summary","body":"A website that can access companies by ticker and show every single data point through google graphs."},{"header":"Inspiration","body":"While trying to research for a 10th grade research paper, I found the Security and Exchange Commission's API for their publicly available       data on publicly traded companies. It was all there, for free, in JSON. After looking around a bit, I realized nobody was taking advantage of this API -       not even the SEC - to make it easier for people to obtain graphs and data of niche data points on public companies. That's why my first sizable coding project      was to code a website to graph the data of any company with data points available from the SEC's API. With this website, researchers could easily access      any data point about any public company with a few clicks."},{"header":"Development","body":"Because this was my first react/next.js website, I threw myself off into the deep end and made some mistakes early on. I wasn't aware of Next's         backend capabilities, so I coded a frontend and backend (for accessing the SEC's API, as they don't allow client-side calls) in two different repositiories.        A huge challenge was navigating the SEC's json - there were a ton of null fields and junk making it difficult to navigate the json.         I had to do a ton of filtering and copying json with no documentation describing its structure.         I struggled a lot with the idea of react, a framework that approaches programming extremely differently from the basic python programs I had written before.        The idea of a framework in and of itself was challenging, especially to someone learning how to code on their own. However, the final result made everything         worth it - it was my first real, malleable software project that accomplished a real goal."}]},{"shortname":"terminaldraw","name":"terminal-draw","favorite":false,"desc":"drawing in the terminal!","links":{"gh":"github.com/lolasanchezz/terminal-draw","demo":"github.com/lolasanchezz/terminal-draw/releases/tag/v1.0"},"images":[{"src":"ss.png","subtitle":"a drawing!","asp":0.65}],"text":[{"header":"Summary","body":"A go cli with bubbletea that allows one to draw in the terminal!"},{"header":"Inspiration","body":"This project was for a Hack Club program called terminal-craft, which gives awards to projects that use the terminal in a novel way. I was experimenting      with ASCII art, and thought, 'hey, it would be really cool if there was some sort of program that allowed you to draw with ascii in the original ascii art inventor,      the terminal!'. So that's what I did."},{"header":"Result","body":"The end result was a Go CLI, once again with Bubble Tea, that allows drawing with ascii characters simply by clicking and dragging. There are different         brush sizes, colors, characters, and an eraser and clear button. Overall, it's a project that satisfied a small goal of mine and made the terminal a little more fun."}]},{"shortname":"self-hosting","name":"self hosting","favorite":false,"desc":"serving websites and services from the pi 5","links":{"gh":"","demo":"secretcrib.mooo.com"},"images":[{"src":"homepage.png","subtitle":"the default html page","asp":0.65},{"src":"server.png","subtitle":"my pi 5 on my wall with a 3d printed case!","asp":0.8}],"text":[{"header":"Summary","body":"Nginx and configuration on my pi 5!"},{"header":"Inspiration","body":"I needed a place to host websites, minecraft servers, and ssh servers, so I decided to       set up a raspberry pi 5 at home. I've always liked the idea of having one's own technology be       independent and only answer to their user, rather than a larger company. With self-hosting, everything       is completely clear, and my servives are completely in my control. Plus, it's nice having a       physical version of the websites I make."},{"header":"Result","body":"So far, I only have one Raspberry Pi 5 with Raspberry Pi OS Bookworm, with a usb flash drive. It         serves websites through NGINX and Let's Encrypt, which allows me to buy different domains, alias         them to the same freedns name, and have NGINX redirect traffic based on the domain name. I also have a local SSH server running,         Soft Serve from Charm Bracelet, which allows me to back up local repos without relying on github."}]}]